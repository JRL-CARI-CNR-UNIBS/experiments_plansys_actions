// Copyright 2019 Intelligent Robotics Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <plansys2_pddl_parser/Utils.h>

#include <memory>

#include "plansys2_msgs/msg/action_execution_info.hpp"
#include "plansys2_msgs/msg/plan.hpp"
#include "plansys2_msgs/action/execute_plan.hpp"
#include "plansys2_msgs/msg/plan_execution_data_collection.hpp"
#include "plansys2_domain_expert/DomainExpertClient.hpp"
#include "plansys2_executor/ExecutorClient.hpp"
#include "plansys2_planner/PlannerClient.hpp"
#include "plansys2_problem_expert/ProblemExpertClient.hpp"
#include "plansys2_knowledge_base_msgs/srv/get_plan_metadata.hpp"

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include <rclcpp/service.hpp>
#include <std_srvs/srv/trigger.hpp>

#include <fstream>
#include <random>

using namespace std::chrono_literals;

class ExplorationExploitationLoopController : public rclcpp::Node
{
public:
  ExplorationExploitationLoopController()
  : rclcpp::Node("experiments_controller"), state_(STARTING)
  {
    declare_parameter<std::string>("problem", std::string(""));
    declare_parameter<std::string>("goal", std::string(""));

    declare_parameter<std::vector<std::string>>("initial_predicates", std::vector<std::string>());
    declare_parameter<std::vector<std::string>>("reset_predicates", std::vector<std::string>());  
    declare_parameter<std::string>("reset_world_goal", std::string(""));
    get_parameter("initial_predicates", initial_predicates_);
    get_parameter("reset_predicates", reset_predicates_);
    get_parameter("reset_world_goal", reset_world_goal_);

    get_plan_metadata_client_ = create_client<plansys2_knowledge_base_msgs::srv::GetPlanMetadata>("plan_uncertainty");
    if(!get_plan_metadata_client_->wait_for_service(5s)) {
      RCLCPP_WARN(get_logger(), "Service get_plan_metadata not available. Uncertainty will not be used.");
    }
  }

  typedef enum {STARTING, INIT, PLANNED, EXECUTE, FINISH, RESET, RESETTED} StateType;

  StateType get_state()
  {
    return state_;
  }

  bool executing()
  {
    return executor_client_->execute_and_check_plan(); 
  }
  plansys2_msgs::msg::Plan get_executed_plan()
  {
    return execute_plan_;
  }

  bool is_finish()
  {
    bool is_finish = !executor_client_->execute_and_check_plan() && executor_client_->getResult();
    if(is_finish) {
      if(state_ == RESET) {
        state_ = RESETTED;
      }
      else {
        state_ = FINISH;
      }
    }
    return is_finish;
  }

  std::optional<plansys2_msgs::action::ExecutePlan::Result> get_execution_result()
  {
    return executor_client_->getResult();
  }

  void init()
  {
    domain_expert_ = std::make_shared<plansys2::DomainExpertClient>();
    planner_client_ = std::make_shared<plansys2::PlannerClient>();
    problem_expert_ = std::make_shared<plansys2::ProblemExpertClient>();
    executor_client_ = std::make_shared<plansys2::ExecutorClient>();
    init_knowledge();
    state_ = INIT;
  }

  void init_knowledge()
  {
    std::string problem;
    get_parameter_or("problem", problem, std::string(""));

    problem_expert_->addProblem(problem);
    
  }
  
  void plan()
  {
    std::string goal;

    get_parameter_or("goal", goal, std::string(""));
    if(!goal.empty())
    {
      if(!problem_expert_->clearGoal())
      {
        throw std::runtime_error("Goal of the problem file is not cleared correctly.");
      }
      if(!problem_expert_->setGoal(plansys2::Goal(goal.c_str())))
      {
        throw std::runtime_error("Goal defined into param is not set correctly.");
      }
      RCLCPP_INFO(get_logger(), "Goal of the problem is overritten by the param.");
    }

    // Compute the plan
    domain_ = domain_expert_->getDomain();
    problem_ = problem_expert_->getProblem();
    auto plan = planner_client_->getPlan(domain_, problem_);

    if (!plan.has_value()) {
      std::cout << "Could not find plan to reach goal " <<
        parser::pddl::toString(problem_expert_->getGoal()) << std::endl;
      return;
    }
    
    RCLCPP_INFO(get_logger(), "Plan:");
    for(const auto & item: plan.value().items)
    {
      RCLCPP_INFO(get_logger(), "[%f] Action: %s, Duration: %f", item.time, item.action.c_str(), item.duration);
    }
    execute_plan_ = plan.value();
    state_ = PLANNED;
  }
  std::optional<plansys2_knowledge_base_msgs::msg::PlanMetadata> retrieve_plan_metadata()
  {
    if(!get_plan_metadata_client_->service_is_ready())
    {
      RCLCPP_ERROR(get_logger(), "Service get_plan_metadata not available.");
      return {};
    }
    if(domain_.empty() || problem_.empty())
    {
      RCLCPP_ERROR(get_logger(), "Domain, problem not set.");
      return {};
    }
    auto get_plan_metadata_request = std::make_shared<plansys2_knowledge_base_msgs::srv::GetPlanMetadata::Request>();
    get_plan_metadata_request->domain = domain_;
    get_plan_metadata_request->problem = problem_;
    get_plan_metadata_request->plan = execute_plan_;
    auto future_result = get_plan_metadata_client_->async_send_request(get_plan_metadata_request);
    rclcpp::spin_until_future_complete(this->get_node_base_interface(), future_result);
    auto result = *future_result.get();
    if(!result.success)
    {
      RCLCPP_ERROR(get_logger(), "Error getting plan metadata: %s.", result.error_info.c_str());
      return {};
    }
    RCLCPP_INFO(get_logger(), "Plan metadata: %f", result.plan_metadata.expected_value);
    RCLCPP_INFO(get_logger(), "Plan metadata: %f", result.plan_metadata.std_dev);
    return result.plan_metadata;  
  }

  void execute()
  {
    if (executor_client_->start_plan_execution(execute_plan_)) {
      state_ = EXECUTE;
    }
  }

  void plan_execute()
  {
    std::string goal;

    get_parameter_or("goal", goal, std::string(""));
    if(!goal.empty())
    {
      if(!problem_expert_->clearGoal())
      {
        throw std::runtime_error("Goal of the problem file is not cleared correctly.");
      }
      if(!problem_expert_->setGoal(plansys2::Goal(goal.c_str())))
      {
        throw std::runtime_error("Goal defined into param is not set correctly.");
      }
      RCLCPP_INFO(get_logger(), "Goal of the problem is overritten by the param.");
    }

    // Compute the plan
    domain_ = domain_expert_->getDomain();
    problem_ = problem_expert_->getProblem();
    auto plan = planner_client_->getPlan(domain_, problem_);

    if (!plan.has_value()) {
      std::cout << "Could not find plan to reach goal " <<
        parser::pddl::toString(problem_expert_->getGoal()) << std::endl;
      return;
    }
    
    RCLCPP_INFO(get_logger(), "Plan:");
    for(const auto & item: plan.value().items)
    {
      RCLCPP_INFO(get_logger(), "[%f] Action: %s, Duration: %f", item.time, item.action.c_str(), item.duration);
    }
    // Execute the plan
    execute_plan_ = plan.value();
    if (executor_client_->start_plan_execution(execute_plan_)) {
      state_ = EXECUTE;
    }
  }
  bool reset_state_variables()
  {
    problem_.clear();
    domain_.clear();

    for(const auto & predicate: reset_predicates_)
    {
      if(!problem_expert_->removePredicate(plansys2::Predicate(predicate))) {
        RCLCPP_ERROR(get_logger(), "Predicate %s not removed.", predicate.c_str());
        return false;
      }
    }
    for(const auto & predicate: initial_predicates_)
    {
      if(!problem_expert_->addPredicate(plansys2::Predicate(predicate))) {
        RCLCPP_ERROR(get_logger(), "Predicate %s not added.", predicate.c_str());
        return false;
      }
    }
    return true;
  }
  void reset_world_state()
  {
    if(reset_world_goal_.empty()) {
      return;
    }

    if(!problem_expert_->clearGoal()) {
      throw std::runtime_error("Goal of the problem file is not cleared correctly.");
    }
    if(!problem_expert_->setGoal(plansys2::Goal(reset_world_goal_.c_str()))) {
      throw std::runtime_error("Goal defined into param is not set correctly.");
    }
    auto domain = domain_expert_->getDomain();
    auto problem = problem_expert_->getProblem();
    auto plan = planner_client_->getPlan(domain, problem);

    if (!plan.has_value()) {
      std::cout << "Could not find plan to reach goal " <<
        parser::pddl::toString(problem_expert_->getGoal()) << std::endl;
      return;
    }
    if (executor_client_->start_plan_execution(plan.value())) {
      state_ = RESET;
    }
  }

private:
  StateType state_;

  std::shared_ptr<plansys2::DomainExpertClient> domain_expert_;
  std::shared_ptr<plansys2::PlannerClient> planner_client_;
  std::shared_ptr<plansys2::ProblemExpertClient> problem_expert_;
  std::shared_ptr<plansys2::ExecutorClient> executor_client_;

  rclcpp::Client<plansys2_knowledge_base_msgs::srv::GetPlanMetadata>::SharedPtr get_plan_metadata_client_;
  std::vector<std::string> initial_predicates_;
  std::vector<std::string> reset_predicates_;
  std::string reset_world_goal_;
  plansys2_msgs::msg::Plan execute_plan_;

  std::string domain_, problem_;
};

int main(int argc, char ** argv)
{
  std::random_device rd;  
  std::mt19937 gen(rd()); // Mersenne Twister Generator
  std::uniform_real_distribution<> dis(0.0, 1.0); // Uniform distribution [0, 1]

  rclcpp::init(argc, argv);
  
  auto node = std::make_shared<ExplorationExploitationLoopController>();

  // Knowledge clients
  auto initialize_knowledge_client = node->create_client<std_srvs::srv::Trigger>("initialize_knowledge");
  auto generate_sampled_problem_client = node->create_client<std_srvs::srv::Trigger>("generate_problem");
  auto save_problem_client = node->create_client<std_srvs::srv::Trigger>("save_problem");
  
  // Humans scene clients
  auto spawn_humans_client = node->create_client<std_srvs::srv::Trigger>("spawn_all_entities");
  auto remove_humans_client = node->create_client<std_srvs::srv::Trigger>("delete_all_entities");

  // Wait all services
  if(!initialize_knowledge_client->wait_for_service(5s)) {
    RCLCPP_ERROR(node->get_logger(), "Service initialize_knowledge not available.");
    return 0;
  }
  if(!generate_sampled_problem_client->wait_for_service(5s)) {
    RCLCPP_ERROR(node->get_logger(), "Service generate_problem not available.");
    return 0;
  }
  if(!save_problem_client->wait_for_service(5s)) {
    RCLCPP_ERROR(node->get_logger(), "Service save_problem not available.");
    return 0;
  }
  if(!spawn_humans_client->wait_for_service(5s)) {
    RCLCPP_ERROR(node->get_logger(), "Service spawn_entity not available.");
    return 0;
  }
  if(!remove_humans_client->wait_for_service(5s)) {
    RCLCPP_ERROR(node->get_logger(), "Service delete_entity not available.");
    return 0;
  }
  // Waiting services
  
  auto plan_execution_data_pub = node->create_publisher<plansys2_msgs::msg::PlanExecutionDataCollection>("plan_execution_data_collection", 10);

  // Parameters declaration
  node->declare_parameter<int>("n_execution", 1);
  node->declare_parameter<int>("iterations_with_humans", 1);
  node->declare_parameter<double>("human_spawning_probability", 0.5);
  node->declare_parameter<double>("human_spawning_probability_after_iterations", 0.5);
  node->declare_parameter<bool>("initialize_knowledge", false);
  node->declare_parameter<bool>("exploration", false);

  RCLCPP_INFO(node->get_logger(), "Iterations with humans: %d", node->get_parameter("iterations_with_humans").as_int());
  RCLCPP_INFO(node->get_logger(), "Human spawning probability: %f", node->get_parameter("human_spawning_probability").as_double());
  RCLCPP_INFO(node->get_logger(), "Human spawning probability after iterations: %f", node->get_parameter("human_spawning_probability_after_iterations").as_double());
  RCLCPP_INFO(node->get_logger(), "Initialize knowledge: %d", node->get_parameter("initialize_knowledge").as_bool());
  RCLCPP_INFO(node->get_logger(), "Exploration: %d", node->get_parameter("exploration").as_bool());

  // Parameters reading
  int n_execution = node->get_parameter("n_execution").as_int();
  int iterations_with_humans = node->get_parameter("iterations_with_humans").as_int();
  if(iterations_with_humans < 0) {
    RCLCPP_WARN(node->get_logger(), "Iterations with humans must be greater than 0. Set to 0");
    iterations_with_humans = 0;
  }
  double human_spawning_probability = node->get_parameter("human_spawning_probability").as_double();
  double human_spawning_probability_after_iterations = node->get_parameter("human_spawning_probability_after_iterations").as_double();
  bool exploration = node->get_parameter("exploration").as_bool();
  bool initialize_knowledge = node->get_parameter("initialize_knowledge").as_bool();
  
  node->init();

  // Initialize knowledge base metadata mongodb
  if(initialize_knowledge) {
    if(initialize_knowledge_client->wait_for_service(1s)) {
      auto future_result = initialize_knowledge_client->async_send_request(std::make_shared<std_srvs::srv::Trigger::Request>());
      rclcpp::spin_until_future_complete(node->get_node_base_interface(), future_result);
      auto result = future_result.get();
      if(!result->success) {
        RCLCPP_ERROR(node->get_logger(), "Service failed.");
        return 0;
      }
      RCLCPP_INFO(node->get_logger(), "Knowledge initialized.");
    }
    else {
      RCLCPP_ERROR(node->get_logger(), "Service not available.");
      return 0;
    }
  }

  int plan_execution = 0;
  if(plan_execution < iterations_with_humans)
  {
    double random_value = dis(gen);
    RCLCPP_INFO(node->get_logger(), "Random value: %f", random_value);
    if (random_value < human_spawning_probability) {
      RCLCPP_INFO(node->get_logger(), "Spawning humans.");
      auto future_result = spawn_humans_client->async_send_request(std::make_shared<std_srvs::srv::Trigger::Request>());
      rclcpp::spin_until_future_complete(node->get_node_base_interface(), future_result);
      auto result = future_result.get();
      if(!result->success) {
        RCLCPP_INFO(node->get_logger(), "Service failed.");
        return 0;
      }
      RCLCPP_INFO(node->get_logger(), "Humans spawned.");
    }
  }

  rclcpp::Time t_start;
  std::optional<plansys2_knowledge_base_msgs::msg::PlanMetadata> plan_metadata;
  try{
    node->plan();
    plan_metadata = node->retrieve_plan_metadata();
    node->execute();
    t_start = node->now();
  }
  catch(const std::exception & e)
  {
    RCLCPP_ERROR(node->get_logger(), e.what());
    return 0;
  }

  rclcpp::Rate rate(5);
  while (rclcpp::ok()) {
    if (node->is_finish()) {
    // if (!node->executing() && node->get_execution_result()) {
      if (node->get_execution_result().value().success) {
        RCLCPP_INFO(node->get_logger(), "Plan finished with success.");
        node->reset_state_variables();
        

        if(plan_execution >= n_execution) {
          RCLCPP_INFO(node->get_logger(), "All executions finished.");
          break;
        }
        
        switch(node->get_state())
        {
          case ExplorationExploitationLoopController::FINISH:
          {
            plansys2_msgs::msg::PlanExecutionDataCollection msg;
            msg.plan = node->get_executed_plan();
            msg.action_execution_status = node->get_execution_result().value().action_execution_status;
            msg.t_start = t_start;
            msg.t_end = node->now();
            if(plan_metadata.has_value()) {
              msg.expected_value = plan_metadata.value().expected_value;
              msg.std_dev = plan_metadata.value().std_dev;
            }
            else{
              RCLCPP_WARN(node->get_logger(), "Plan metadata not available. Take care if you need it!");
            }
            plan_execution_data_pub->publish(msg);
          }
            plan_execution++;

            try{
              RCLCPP_INFO(node->get_logger(), "Resetting the world state.");
              node->reset_world_state();
            }
            catch(const std::exception & e) {
              RCLCPP_ERROR(node->get_logger(), e.what());
              return 0;
            }        
          break;
          case ExplorationExploitationLoopController::RESETTED:
          {
            node->reset_state_variables(); // Again since the plan to achieve start init can contain also...
            RCLCPP_INFO(node->get_logger(), "Plan execution: %d finished.", plan_execution);

            // Remove humans from scene
            auto future = remove_humans_client->async_send_request(std::make_shared<std_srvs::srv::Trigger::Request>());
            rclcpp::spin_until_future_complete(node->get_node_base_interface(), future);
            auto result_remove = future.get();
            if(!result_remove->success) {
              RCLCPP_ERROR(node->get_logger(), "Service %s failed.", remove_humans_client->get_service_name());
              return 0;
            }

            //  Spawn humans in the scene according to the probability
            double random_value = dis(gen);
            RCLCPP_INFO(node->get_logger(), "Random value: %f", random_value);
            bool should_spawn_humans = (random_value < (plan_execution < iterations_with_humans ? human_spawning_probability : human_spawning_probability_after_iterations));

            if (should_spawn_humans) {
              auto future_result = spawn_humans_client->async_send_request(std::make_shared<std_srvs::srv::Trigger::Request>());
              rclcpp::spin_until_future_complete(node->get_node_base_interface(), future_result);
              auto result = future_result.get();
              if(!result->success) {
                RCLCPP_ERROR(node->get_logger(), "Service failed.");
                return 0;
              }
            }

            // Generate a new problem if exploration is enabled
            if(exploration == true)
            {
              auto future_result = generate_sampled_problem_client->async_send_request(std::make_shared<std_srvs::srv::Trigger::Request>());
              rclcpp::spin_until_future_complete(node->get_node_base_interface(), future_result);
              auto result_generate_prob = future_result.get();
              if(!result_generate_prob->success) {
                RCLCPP_ERROR(node->get_logger(), "Service failed.");
                return 0;
              }
            }

            // Save problem
            auto future_result_save = save_problem_client->async_send_request(std::make_shared<std_srvs::srv::Trigger::Request>());
            rclcpp::spin_until_future_complete(node->get_node_base_interface(), future_result_save);
            auto result_save_prob = future_result_save.get();
            if(!result_save_prob->success) {
              RCLCPP_ERROR(node->get_logger(), "Service failed.");            
            }

            // Execute another plan
            try{
              node->plan();
              plan_metadata = node->retrieve_plan_metadata();
              node->execute();
              t_start = node->now();
            }
            catch(const std::exception & e)
            {
              RCLCPP_ERROR(node->get_logger(), e.what());
              return 0;
            }
            break;
          }
          default:
            RCLCPP_ERROR(node->get_logger(), "State not resetted. %d", node->get_state());
            return 0;
        }
      }
      else { // finished failed
        RCLCPP_INFO(node->get_logger(), "Plan finished with error");
        break;
      }
    }
    // executing
    rate.sleep();
    rclcpp::spin_some(node->get_node_base_interface());
  }

  rclcpp::shutdown();

  return 0;
}
